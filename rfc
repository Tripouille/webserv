Autres trouvailles :
HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all protocol elements except the entity-body.
Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.

vu sur wiki :
431	Request Header Fields Too Large	RFC 658514 : Les entêtes HTTP émises dépassent la taille maximale admise par le serveur.

testeur :
PUT et POST


RFC 7230

2. Architecture

- Etre capable au minimum de parser des données aussi longues que celles qu'on envoie pour un même protocole

- Lorsqu'on envoie du 1.1, il est lisible par du 1.0 (qui ignore les éléments 1.1)
--> ok car les champs du header ne changent pas entre des versions mineures,
seulement le comportement en cas d'absence de header change

- Envoyer un code de statut ou un header field si on ne gère pas bien la version trop haute de la requête
- Répondre par la plus haute version possible (sans avoir une version majeure > la version reçue)
- On peut renvoyer une 505 (HTTP Version Not Supported)

- Renvoyer erreur s'il y a des user info

3. Message format

- Parser le message dans un encodage englobant le US-ASCII

- Rejeter (pour sécurité) message ou ignorer ligne entière s'il y a des whitespace avant un champ du header

- [Start-line = request-line ou status-line]
[Header avec tous ses champs]
[Ligne vide]
[Body]
- bien parser start-line, rejeter si invalide
- d'après le tutoriel : limite de 1024 caractères pour la request-line en cas de GET

- request-line   = method SP request-target SP HTTP-version CRLF
si requestline invalide : 400 (Bad Request), ou 301 (Moved Permanently) si réencode correctement
si method trop longue : 501 (Not Implemented)
getline() pour header puis un recv pour body de la longueur donnée
si target trop longue : 414 (URI Too Long)

- status-line = HTTP-version SP status-code SP (reason-phrase) CRLF

- header field = name : OWS value OWS
ignorer un champ inconnu
si espace entre name et ":" : 400 (Bad Request)

- attendre tout le header avant de le traiter

- listes dans header : plusieurs fois le même nom de champ > concaténer les valeurs avec des virgules entre elles
sauf set-cookie
- rejeter message si obsolete line folding dans header (400 Bad Request) ou le remplacer par SP (1 ou +)
- si valeur de champ trop grosse : erreur appropriée 4xx (ignorer seulement si c'est safe)

- commentaires entre parenthèses (seulement dans certains champs)

- si un transfer coding est inconnu : 501 (Not Implemented)
- attention aux erreurs d'overflow de nombre (content-length)
- voir tous les cas de content-length/transfer-encoding dans la rfc :
CONTENT-LENGTH
seulement si pas de transfer-encoding
que des digits
pas de content-length = content-length 0 = pas de body
attention à la longueur du nombre (overflow)
si plusieurs content-length, 400 (Bad Request)
si recv s'arrête avant, rejeter
voir plus tard pour timeout

si connexion s'arrête ou décodage fail avant d'avoir eu tout, on peut renvoyer une erreur avant de fermer la connexion

on devrait ignorer au moins une ligne vide (\r\n) avant de recevoir la request line
--> décision prise : define pour limite de lignes vides, while (nb_ligne_vide < limit)


bien penser aux limites de taille partout (failles de sécurité)

(4. Transfer Codings : A retourner voir)

5. Message Routing

- accepter, en request-target, une origin-form (juste le chemin et les query) comme une absolute-form (toute l'uri, avec http://)
- accepter aussi "*" pour OPTIONS

- si pas de champ "host", ou en double, ou invalide : 400 (Bad Request)

- le serveur reconstruit la "effective request URI" à partir de la request-target (déjà complète si absolute-form), voir rfc pour détails (à quoi ça sert ??)

6. Connect Management

- c'est notre rôle, rien de spécifié, de gérer la couche connexion (connection failure...)
- la plupart des serveurs maintiennent des milliers de connexions simultanées

- selon certaines conditions (header connection), il faut faire persister la connexion ou la close (à ne pas gérer dans webserv ?)
- le close peut se faire en plusieurs étapes (d'abord le côté write, puis ...)

- si timeout de la connexion > préférable de close correctement la connexion

7. ABNF List Extension: #rule
Rien compris, précisions sur les listes

8. IANA Considerations
Qu'est-ce que IANA : The global coordination of the DNS Root, IP addressing, and other Internet protocol resources is performed as the Internet Assigned Numbers Authority (IANA) functions.
http://www.iana.org/assignments/message-headers/message-headers.xhtml
https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
https://www.iana.org/assignments/media-types/media-types.xhtml
https://www.iana.org/assignments/http-parameters/http-parameters.xhtml (noms pour transfer coding)

9. Security Considerations
- rejeter resquest-target ou request payload trop longs, mais pouvoir en lire de gros
- faire attention aux buffer/arithmetic overflow dans le process des header, méthodes, phrases...


RFC 7231

3. Representation

- "Représentation" = état de la ressource voulue ou à un moment donné, dans une forme communicable
- Les champs du header (Content-Type, Content-Encoding, Content-Language, Content-Location) disent comment interpréter la representation data incluse dans le payload body (si c'est une requête HEAD, les champs sont présents et remplis comme si c'était une GET)

- Content-type = media-type = type "/" subtype *( OWS ";" OWS parameter )
parameter      = token "=" ( token / quoted-string )
sert au format et au modèle de traitement (processing).
Case-insensitive : type, subtype, parameter name.
Valables et équivalents :
text/html;charset=utf-8    <-- préféré
text/html;charset=UTF-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"

- Etre capable de parser des médias de texte utilisant différents type de retour à la ligne (CRLF, CR, LF).

- Il existe des "multipart types" qui permettent d'encapsuler plusieurs représentations dans un seul body.

- Si pas de Content-Type : le bénéficiaire (recipient) peut assumer un media type "application/octet-stream" ou déterminer son type lui-même.

- Pour Accept-Language et Content-Language : https://tools.ietf.org/html/rfc5646#section-2.1
Généralement : un language très courant, "-", une sous-catégorie (en-US, en-CA...).
Si Content-Language absent : le contenu est pour tous les languages.
Ce n'est pas réservé aux textes.

- Content-Location est une URI qui identifie la ressource dont la représentation est dans le body (ne pas y faire confiance ; sert à des choses non sécurisées comme un historique). Ne remplace pas la effective request URI.
Si le serveur reçoit un Content-Location dans une request, cela veut dire que le user agent a fourni un lien retour vers la source et cela ne devrait pas changer le résultat de la requête.

- Payload header fields (décrivent véritablement le contenu du body et non la représentation associée) : Content-Length, Content-Range, Trailer, Transfer-Encoding

4. Request Methods

GET (obligatoire à gérer pour tous serveurs) : Transfer a current representation of the target resource
HEAD (obligatoire à gérer pour tous serveurs) : Same as GET, but only transfer the status line and header section
POST : Perform resource-specific processing on the request payload
PUT : Replace all current representations of the target resource with the request payload
DELETE : Remove all current representations of the target resource
CONNECT : Establish a tunnel to the server identified by the target resource
OPTIONS : Describe the communication options for the target resource
TRACE : Perform a message loop-back test along the path to the target resource
Méthode non reconnue : 501 (Not Implemented), non autorisée pour cette ressource : 405 (Method Not Allowed)

Head : les payload header fields peuvent être enlevés.
Succès sur création de ressources pour POST : 201 (Created), avec header Location indiquant où se trouve la ressource.
Si PUT crée une ressource : 201 (Created), sinon la ressource a déjà une représentation et : 200 (OK) ou 204 (No Content)
(...etc. pour toutes méthodes)

5. Request Header Fields

