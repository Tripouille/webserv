Todo list :
test nginx with "Content-Length:" (no value)
détecter un ctrl+C (ou le signal ?) pour fermer la connexion

Autres trouvailles :
HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all protocol elements except the entity-body.
Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.

vu sur wiki :
431	Request Header Fields Too Large	RFC 658514 : Les entêtes HTTP émises dépassent la taille maximale admise par le serveur.

testeur :
PUT et POST


RFC 7230

2. Architecture

- Etre capable au minimum de parser des données aussi longues que celles qu'on envoie pour un même protocole

- Lorsqu'on envoie du 1.1, il est lisible par du 1.0 (qui ignore les éléments 1.1)
--> ok car les champs du header ne changent pas entre des versions mineures,
seulement le comportement en cas d'absence de header change

- Envoyer un code de statut ou un header field si on ne gère pas bien la version trop haute de la requête
- Répondre par la plus haute version possible (sans avoir une version majeure > la version reçue)
- On peut renvoyer une 505 (HTTP Version Not Supported)

- Renvoyer erreur s'il y a des user info

3. Message format

- Parser le message dans un encodage englobant le US-ASCII

- Rejeter (pour sécurité) message ou ignorer ligne entière s'il y a des whitespace avant un champ du header

- [Start-line = request-line ou status-line]
[Header avec tous ses champs]
[Ligne vide]
[Body]
- bien parser start-line, rejeter si invalide
- d'après le tutoriel : limite de 1024 caractères pour la request-line en cas de GET

- request-line   = method SP request-target SP HTTP-version CRLF
si requestline invalide : 400 (Bad Request), ou 301 (Moved Permanently) si réencode correctement
si method trop longue : 501 (Not Implemented)
getline() pour header puis un recv pour body de la longueur donnée
si target trop longue : 414 (URI Too Long)

- status-line = HTTP-version SP status-code SP (reason-phrase) CRLF

- header field = name : OWS value OWS
ignorer un champ inconnu
si espace entre name et ":" : 400 (Bad Request)

- attendre tout le header avant de le traiter

- listes dans header : plusieurs fois le même nom de champ > concaténer les valeurs avec des virgules entre elles
sauf set-cookie
- rejeter message si obsolete line folding dans header (400 Bad Request) ou le remplacer par SP (1 ou +)
- si valeur de champ trop grosse : erreur appropriée 4xx (ignorer seulement si c'est safe)

- commentaires entre parenthèses (seulement dans certains champs)

- si un transfer coding est inconnu : 501 (Not Implemented)
- attention aux erreurs d'overflow de nombre (content-length)
- voir tous les cas de content-length/transfer-encoding dans la rfc :
CONTENT-LENGTH
seulement si pas de transfer-encoding
que des digits
pas de content-length = content-length 0 = pas de body
attention à la longueur du nombre (overflow)
si plusieurs content-length, 400 (Bad Request)
si recv s'arrête avant, rejeter
voir plus tard pour timeout

si connexion s'arrête ou décodage fail avant d'avoir eu tout, on peut renvoyer une erreur avant de fermer la connexion

on devrait ignorer au moins une ligne vide (\r\n) avant de recevoir la request line
--> décision prise : define pour limite de lignes vides, while (nb_ligne_vide < limit)


bien penser aux limites de taille partout (failles de sécurité)

(4. Transfer Codings : A retourner voir)

5. Message Routing

- accepter, en request-target, une origin-form (juste le chemin et les query) comme une absolute-form (toute l'uri, avec http://)
- accepter aussi "*" pour OPTIONS

- si pas de champ "host", ou en double, ou invalide : 400 (Bad Request)

- le serveur reconstruit la "effective request URI" à partir de la request-target (déjà complète si absolute-form), voir rfc pour détails (à quoi ça sert ??)

6. Connect Management

- c'est notre rôle, rien de spécifié, de gérer la couche connexion (connection failure...)
- la plupart des serveurs maintiennent des milliers de connexions simultanées

- selon certaines conditions (header connection), il faut faire persister la connexion ou la close (à ne pas gérer dans webserv ?)
- le close peut se faire en plusieurs étapes (d'abord le côté write, puis ...)

- si timeout de la connexion > préférable de close correctement la connexion

7. ABNF List Extension: #rule
Rien compris, précisions sur les listes

8. IANA Considerations
Qu'est-ce que IANA : The global coordination of the DNS Root, IP addressing, and other Internet protocol resources is performed as the Internet Assigned Numbers Authority (IANA) functions.
http://www.iana.org/assignments/message-headers/message-headers.xhtml
https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
https://www.iana.org/assignments/media-types/media-types.xhtml
https://www.iana.org/assignments/http-parameters/http-parameters.xhtml (noms pour transfer coding)

9. Security Considerations
- rejeter resquest-target ou request payload trop longs, mais pouvoir en lire de gros
- faire attention aux buffer/arithmetic overflow dans le process des header, méthodes, phrases...


RFC 7231

3. Representation

- "Représentation" = état de la ressource voulue ou à un moment donné, dans une forme communicable
- Les champs du header (Content-Type, Content-Encoding, Content-Language, Content-Location) disent comment interpréter la representation data incluse dans le payload body (si c'est une requête HEAD, les champs sont présents et remplis comme si c'était une GET)

- Content-type = media-type = type "/" subtype *( OWS ";" OWS parameter )
parameter      = token "=" ( token / quoted-string )
sert au format et au modèle de traitement (processing).
Case-insensitive : type, subtype, parameter name.
Valables et équivalents :
text/html;charset=utf-8    <-- préféré
text/html;charset=UTF-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"

- Etre capable de parser des médias de texte utilisant différents type de retour à la ligne (CRLF, CR, LF).

- Il existe des "multipart types" qui permettent d'encapsuler plusieurs représentations dans un seul body.

- Si pas de Content-Type : le bénéficiaire (recipient) peut assumer un media type "application/octet-stream" ou déterminer son type lui-même. (bref, nous on envoie pas de content-type si type inconnu)

- Pour Accept-Language et Content-Language : https://tools.ietf.org/html/rfc5646#section-2.1
Généralement : un language très courant, "-", une sous-catégorie (en-US, en-CA...).
Si Content-Language absent : le contenu est pour tous les languages.
Ce n'est pas réservé aux textes.

- Content-Location est une URI qui identifie la ressource dont la représentation est dans le body (ne pas y faire confiance ; sert à des choses non sécurisées comme un historique). Ne remplace pas la effective request URI.
Si le serveur reçoit un Content-Location dans une request, cela veut dire que le user agent a fourni un lien retour vers la source et cela ne devrait pas changer le résultat de la requête.

- Payload header fields (décrivent véritablement le contenu du body et non la représentation associée) : Content-Length, Content-Range, Trailer, Transfer-Encoding

4. Request Methods

GET (obligatoire à gérer pour tous serveurs) : Transfer a current representation of the target resource
HEAD (obligatoire à gérer pour tous serveurs) : Same as GET, but only transfer the status line and header section
POST : Perform resource-specific processing on the request payload
PUT : Replace all current representations of the target resource with the request payload
DELETE : Remove all current representations of the target resource
CONNECT : Establish a tunnel to the server identified by the target resource
OPTIONS : Describe the communication options for the target resource
TRACE : Perform a message loop-back test along the path to the target resource
Méthode non reconnue : 501 (Not Implemented), non autorisée pour cette ressource : 405 (Method Not Allowed)

Head : les payload header fields peuvent être enlevés.
Succès sur création de ressources pour POST : 201 (Created), avec header Location indiquant où se trouve la ressource.
Si PUT crée une ressource : 201 (Created), sinon la ressource a déjà une représentation et : 200 (OK) ou 204 (No Content)
(...etc. pour toutes méthodes)

5. Request Header Fields

6.

7. Response Header Fields

7.1.  Control Data
Seulement ceux qui sont dans le sujet :
Date              | Section 7.1.1.2          | SUJET
Location          | Section 7.1.2            | SUJET
Retry-After       | Section 7.1.3            | SUJET

HTTP-Date : 3 formats possibles à recevoir, meilleur = IMF-fixdate, à renvoyer
Rare de le recevoir
Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
case-sensitive
si on utilise heure locale (et non UTC = GMT) : utiliser NTP ([RFC5905]) pour synchroniser avec UTC
Header Date = juste avant que le payload (body?) soit généré, mais ok n'importe quand
Possible de renvoyer Date tout le temps, obligatoire sauf pour les 1xx et 5xx
notre code n'affiche la date correctement en anglais que parce qu'on a une locale anglaise (hébergé sur un PC français, notre serveur renverrait une mauvaise date)

Location = URI-reference
201 > Location = ressource crée
3xx > Location = ressource vers laquelle on a été redirigé (absolu ou relatif, exemple "Location: http://www.example.org/People.html#tim" ou "Location: /People.html#tim")
nginx ne semble pas en mettre ni sur un 200 ni 404

Retry-After :
Indique combien de temps l'utilisateur doit attendre avant de faire la requête suivante
Quand on envoie une réponse 503 (Service Unavailable), temps d'attente estimé
Quand on envoie une réponse 3xx (Redirection), indique le temps minimum à attendre avant de faire la requête redirigée
Retry-After = HTTP-date / delay-seconds
delay-seconds  = 1*DIGIT
Exemples :
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120

7.2.  Validator Header Fields
Dans réponse réussie
-> RFC 7232 2.Validators, servent notamment à invalider le cache
2.2. Last-Modified : même format que Date
A envoyer autant que possible, dès qu'on connaît la date de dernière modification
Est le plus récent si la représentation est issue de différentes parties
Déterminer cette date au plus proche de celle du header field "Date", et le "Last-Modified" doit bien être plus tôt que ou égal à "Date"

7.3 Authentication Challenges
WWW-Authenticate (Section 4.1 of [RFC7235]) :
Si on envoie une réponse 401 (Unauthorized), on doit envoyer ce header field contenant au moins un challenge
On peut aussi l'envoyer dans d'autres cas pour indiquer que d'autres identifiants(credentials, une autre identité) pouvait affecter la réponse
Exemple : WWW-Authenticate: Newauth realm="apps", type=1, title="Login to \"apps\"", Basic realm="simple"

7.4 Response Context
Allow :
Liste les méthodes suportées
Exemple : Allow: GET, HEAD, PUT
Doit être présent en cas de réponse 405 (Method Not Allowed) (différence avec 501 Not Implemented : dans la 405, la méthode est connue du serveur mais non supportée par la ressource ciblée)
Allow peut aussi être vide si aucune méthode n'est autorisée, par exemple si la ressource a été temporairement désactivée

Server :
Information à propos du logiciel utilisé par le serveur
Utilisé par les clients par exemplepour identifier les problèmes de compatibilité
Pas obligatoire
Server = product *( RWS ( product / comment ) )
Exemple: Server: CERN/3.0 libwww/2.17
Exemple (de nginx) : Server: nginx/1.14.0 (Ubuntu)
Pour sécurité : ne pas envoyer trop d'infos